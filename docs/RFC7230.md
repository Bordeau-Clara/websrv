Voici les éléments clés du RFC 7230 (HTTP/1.1: Message Syntax and Routing) que tu dois absolument implémenter pour un serveur HTTP/1.1 conforme, surtout dans le cadre de ton projet Webserv. Je me concentre sur ce qui est indispensable pour répondre aux exigences du sujet et éviter les pièges courants.

1. Format Général des Messages HTTP
A. Structure de Base

Un message HTTP est soit une requête (client → serveur), soit une réponse (serveur → client).
Format général :
 Copystart-line CRLF
*(header-field CRLF)
CRLF
[message-body]

start-line : Diffère entre requête et réponse.
header-field : nom: valeur (insensible à la casse pour le nom).
CRLF : \r\n (obligatoire, pas juste \n).
Corps optionnel : Présent seulement si indiqué par les en-têtes.




2. Requête HTTP (Request)
A. Start-Line (Ligne de Début)


Format :
 Copymethod SP request-target SP HTTP-version CRLF

method : GET, POST, DELETE (au minimum pour ton projet).
request-target :

Forme la plus courante : origin-form = /chemin/ressource?query (ex: /index.html).
Absolu : http://example.com/chemin (peu utilisé en pratique avec HTTP/1.1).


HTTP-version : Doit être HTTP/1.1 (ton serveur doit le supporter).



Exemple :
 CopyGET /index.html HTTP/1.1


B. En-têtes Obligatoires ou Critiques


Host (obligatoire en HTTP/1.1) :

Indique le nom de domaine et le port du serveur.
Exemple : Host: example.com:8080
Pourquoi : Permet l’hébergement virtuel (plusieurs sites sur une même IP).



Content-Length :

Obligatoire si la requête a un corps (ex: POST).
Indique la taille du corps en octets.
Exemple : Content-Length: 34



Transfer-Encoding :

Si présent avec chunked, le corps est envoyé par chunks (ton serveur doit savoir déchunker).
Exemple : Transfer-Encoding: chunked



Autres en-têtes utiles :

Connection: keep-alive (pour les connexions persistantes).
User-Agent, Accept, etc. (optionnels mais courants).




3. Réponse HTTP (Response)
A. Start-Line (Ligne de Début)


Format :
 CopyHTTP-version SP status-code SP reason-phrase CRLF

HTTP-version : HTTP/1.1.
status-code : Code numérique (ex: 200, 404).
reason-phrase : Texte descriptif (ex: OK, Not Found).



Exemple :
 CopyHTTP/1.1 200 OK


B. Codes de Statut à Implémenter
CodeSignificationObligatoire ?200OKOui201CreatedOui (pour POST)204No ContentUtile301Moved PermanentlyOui (redirections)400Bad RequestOui403ForbiddenOui404Not FoundOui405Method Not AllowedOui500Internal Server ErrorOui501Not ImplementedUtile

Pages d’erreur par défaut : Ton serveur doit renvoyer une page HTML simple pour chaque code d’erreur.

C. En-têtes Obligatoires ou Critiques


Content-Length :

Obligatoire si le corps a une taille connue.
Exemple : Content-Length: 1024



Transfer-Encoding: chunked :

Si tu utilises le chunking (optionnel mais utile pour les réponses dynamiques).



Connection :

Connection: close pour fermer la connexion après la réponse.
Connection: keep-alive pour garder la connexion ouverte.



Content-Type :

Indique le type MIME du corps (ex: text/html, image/png).
Exemple : Content-Type: text/html




4. Gestion du Corps (Message Body)
A. Longueur du Corps

Trois cas possibles :

Content-Length : Le corps a une taille fixe.
Transfer-Encoding: chunked : Le corps est envoyé par chunks (ton serveur doit savoir lire/écrire en chunked).
Pas de corps : Pour les réponses comme 204 No Content ou certaines requêtes GET.



B. Chunked Transfer Encoding


Si Transfer-Encoding: chunked :

Le corps est divisé en chunks de taille variable.
Chaque chunk commence par sa taille en hexadécimal, suivi de CRLF, puis des données, puis CRLF.
Le dernier chunk est de taille 0.
Exemple :
 Copy4\r\n
Wiki\r\n
5\r\n
pedia\r\n
0\r\n
\r\n




Ton serveur doit :

Déchunker les requêtes entrantes (si Transfer-Encoding: chunked).
Chunkifier les réponses si nécessaire (optionnel mais utile pour les CGI).




5. Connexions Persistantes (Keep-Alive)


HTTP/1.1 utilise par défaut des connexions persistantes (plusieurs requêtes/réponses sur une même connexion TCP).


Pour fermer la connexion :

Le client ou le serveur peut envoyer Connection: close.
Sinon, la connexion reste ouverte jusqu’à timeout.



Ton serveur doit :

Supporter keep-alive (attendre une nouvelle requête après avoir envoyé une réponse).
Fermer la connexion après un timeout ou si le client envoie Connection: close.




6. Parsing des En-têtes


Règles strictes :

Les noms d’en-têtes sont insensibles à la casse (ex: host = Host = HOST).
Les valeurs peuvent être combinées si un en-tête apparaît plusieurs fois (ex: Set-Cookie).
Les espaces en début/fin de valeur doivent être ignorés.



Exemple de parsing :
 Copystd::string header_name = "host";
std::string header_value = " example.com:8080 ";
// Après parsing :
// name = "Host"
// value = "example.com:8080"



7. Gestion des Méthodes HTTP


Méthodes à implémenter (selon le sujet) :

GET : Récupérer une ressource.
POST : Envoyer des données (ex: formulaire, upload de fichier).
DELETE : Supprimer une ressource.



Répondre avec 405 Method Not Allowed si une méthode non supportée est utilisée.



8. Gestion des Routes et des Ressources


request-target :

Doit être décodé (ex: %20 → espace).
Doit être résolu vers un fichier ou un script CGI sur le serveur.
Exemple : /images/photo.png → /var/www/images/photo.png.



Redirections :

Si une route est déplacée, renvoyer un 301 Moved Permanently avec l’en-tête Location.




9. Gestion des Erreurs

Requêtes malformées :

Si la syntaxe est invalide (ex: CRLF manquants), renvoyer 400 Bad Request.


Ressource introuvable : 404 Not Found.
Méthode non autorisée : 405 Method Not Allowed.
Erreur interne : 500 Internal Server Error.


10. Exemple Minimal de Requête/Réponse
Requête :
 CopyGET /index.html HTTP/1.1
Host: example.com
Connection: keep-alive
User-Agent: MyBrowser/1.0
Accept: */*
Réponse :
 CopyHTTP/1.1 200 OK
Content-Type: text/html
Content-Length: 13

Hello, world!

11. Points d’Attention Spécifiques

Ne pas lire/écrire sans poll() :

Toujours vérifier que le FD est prêt avant de faire un read/write (sinon, risque de blocage).


Gérer les timeouts :

Fermer les connexions inactives après un délai (ex: 30 secondes).


Ne pas planter :

Même si la requête est invalide, renvoyer une erreur (400) et continuer.


CGI :

Pour les requêtes POST avec corps, passer le corps déchunké au CGI via stdin.
Récupérer la sortie du CGI et la renvoyer au client (avec les bons en-têtes).




12. Ressources pour Aller Plus Loin

RFC 7230 Section 3 : Message Format
RFC 7230 Section 3.3 : Message Body
RFC 7230 Section 6 : Connections


Résumé des Étapes Clés pour Ton Projet

Parser la start-line (méthode, cible, version).
Parser les en-têtes (surtout Host, Content-Length, Transfer-Encoding).
Gérer le corps (selon Content-Length ou chunked).
Traiter la requête (router vers un fichier, un CGI, etc.).
Construire une réponse avec les bons codes et en-têtes.
Gérer les connexions persistantes (keep-alive).
Tester avec telnet pour valider le format des messages.
